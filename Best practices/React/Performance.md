# React Performance

## Asynchronous component loading

Complex applications generally end up having components that aren’t needed for every render. These can be components that:

* Are only shown for routes in the application that are not currently active.
* Are hidden behind a user action, like modals, or popovers.
* Have large dependencies that would slow down the perceived performance of the app.

The solution for these components is to turn them into "async" components, where the code for the component is only loaded on mount (or later), which frees up the CPU for the rest of the application to render synchronously.

React provides a built-in way of creating async components, [`React.lazy()`](https://reactjs.org/docs/code-splitting.html#reactlazy). This can be a viable approach for simpler cases, but it is missing many features that are usually needed:

* As of this writing, components generated by this function do not work with server side rendering.
* Even if the API itself worked for server rendering, there is no way to determine what application bundles will be needed based on the asynchronous components that were rendered. This is important because failing to include the assets for asynchronously-loaded components will cause the server-rendered markup to be discarded, and will force the download of those assets to happen much later during the initial page load.
* It does not have any built-in mechanism to prefetch any of the assets for the page.

To address these problems, we have developed a few custom packages. [`@shopify/react-async`](https://github.com/Shopify/quilt/tree/master/packages/react-async) provides a function to create asynchronous components based on dynamic import statements:

```tsx
import {createAsyncComponent} from '@shopify/react-async';

const MyComponent = createAsyncComponent({
  load: () => import('./MyComponent'),
});
```

The resulting component has the exact same type signature as the component being asynchronously imported, so the library works great with TypeScript. As documented in [`@shopify/sewing-kit-koa`](https://github.com/Shopify/quilt/tree/master/packages/sewing-kit-koa#usage), sewing kit knows how to attach additional metadata to these components in order to extract the assets they represent for server-rendered applications. Finally, these components have useful static members for prefetching the component’s assets. Strategies for doing so are [documented below](#preloading-strategies).

### Defer strategies

By default, components created by `@shopify/react-async` (and those created by `React.lazy`) start loading the component’s code on mount. This is a great start, but you should be mindful of when you can defer that loading even later. There are two key times that asynchronous components on the page could be loaded:

* **On mount**. This is the default if you render the asynchronous components normally in the parent’s render function.
* **On browser idle**. If a component is unlikely to be used until later in the lifecycle of a component, starting its loading when the browser is idle can be an excellent strategy. Doing so leaves the main thread open for other synchronously-rendered components to perform any `componentDidMount`/ `useEffect` callbacks, without having to contend with th asynchronous component starting its initial load. This strategy can make use of [`window.requestIdleCallback`](https://developer.mozilla.org/en-US/docs/Web/API/Window/requestIdleCallback), which the browser exposes to help developers schedule work when there won’t be resource contention.

`@shopify/react-async` makes it easy to use a specific defer strategy. If you want to use a single strategy for all uses of a component, you can pass it as part of the `createAsyncComponent` call. If it needs to be customized for each "instance", you can pass an `async` prop with this information:

```tsx
import {createAsyncComponent, DeferTiming} from '@shopify/react-async';

const MyAlwaysIdleDeferredComponent = createAsyncComponent({
  load: () => import('./MyComponent'),
  defer: DeferTiming.Idle,
});

const MySometimesIdleDeferredComponent = createAsyncComponent({
  load: () => import('./MyComponent'),
});

<MySometimesIdleDeferredComponent async={{defer: DeferTiming.Idle}} />
```

We recommend deferring async component loading to browser idle in the following cases:

* The component is very infrequently used and will not meaningfully change the layout of the parent component when it loads (this is often the case for content in modals and popovers).
* The component does not have any actual UI and is not needed by other synchronous components. This is often the case for things like tracking.

Additionally, deferring until browser idle is useful when prefetching assets for asynchronous components, which is why the `<Prefetch />` components generated by `@shopify/react-async` does it by default.

### Preloading strategies

One major problem with asynchronous components (as compared to components that are included synchronously in the main bundle of the app) is that the user must wait for these scripts to download and execute before any UI is shown. This cost is always present, but in an all-synchronous world, the cost is paid only once, when the page loads.

To address this problem, developers should attempt to preload assets for components that they are fairly confident will be rendered soon. `@shopify/react-async` provides some useful components to do so, organized around three types of "preloading" that are commonly needed in an application:

* **Prefetching**, where we load code for a page that might be visited soon (but are not certain).
* **Preloading**, where we load code for a page that we are almost certain is going to be visited in the next few seconds.
* **Keeping fresh**, where we refresh asynchronous assets for a component that was recently rendered, and where we are likely to return to (for example, we might want to keep asynchronous-loaded parts of a product list page fresh while we are on the details of a single product).

These types are mirrored in static components returned from `createAsyncComponent`:

```tsx
import {createAsyncComponent} from '@shopify/react-async';

const MyComponent = createAsyncComponent({
  load: () => import('./MyComponent'),
});

<MyComponent.Prefetch />
<MyComponent.Preload />
<MyComponent.KeepFresh />
```

What gets rendered by each of these components can be customized using the `renderPrefetch`, `renderPreload`, and `renderKeepFresh` [options](https://github.com/Shopify/quilt/tree/master/packages/react-async#createasynccomponent). You can use this customization to preload additional asynchronous components that yours depends on.

At a minimum, we recommend rendering the `<Prefetch />` for any asynchronous components that are rendered by a route your component links to. This pattern can be generalized using the [`<PrefetchRoute />` component](https://github.com/Shopify/quilt/tree/master/packages/react-async#prefetchroute-and-prefetcher) in `@shopify/react-async`.
