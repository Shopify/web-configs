# React Performance

## Table of contents

1. [Complementary packages](#complementary-packages)
1. [Server rendering](#server-rendering)
1. [Asynchronous component loading](#asynchronous-component-loading)

## Complementary packages

* [`@shopify/react-async`](https://github.com/Shopify/quilt/tree/master/packages/react-async): utilities for creating asynchronously-loaded React components, with support for prefetching and extracting used bundles included in [Sewing Kit](https://github.com/Shopify/sewing-kit)
* [`@shopify/react-graphql`](https://github.com/Shopify/quilt/tree/master/packages/react-graphql): provides a functions to create asynchronous GraphQL query components with built-in prefetching
* [`@shopify/react-import-remote`](https://github.com/Shopify/quilt/tree/master/packages/react-import-remote): provides a React component for performance-conscious loading of external scripts
* [`@shopify/react-html`](https://github.com/Shopify/quilt/tree/master/packages/react-html): provides a `<Preconnect />` component for warming up connections to other domains, and a collection of tools for easily serializing data for server-rendered pages

## Server rendering

Exclusively using client-side rendering means that nothing is shown on the page until the scripts have downloaded and executed, any initial data fetching has been performed, and the app has been rendered for the first time.

Server-side rendering a React application can be a useful tool in reducing the time until a merchant has a page that appears visually complete. However, this does not guarantee good performance. If your JavaScript takes a long time to execute on a fresh page load, there can be a period of time where the app appears to be interactive, but isn’t. Tracking the [first input delay](https://developers.google.com/web/updates/2018/05/first-input-delay) can help you determine whether users are being "tricked" into interacting with the app while initial JavaScript is still executing.

Server-side rendering is also easy to get wrong. If the markup from the server does not match what the client believes the markup should be, the work performed by the server is basically thrown away. There are a few common patterns that cause these kinds of difference in markup:

* **Not serializing data from the server correctly.** If a piece of information was fetched by the server, it must include that in the HTML response. Examples include everything from GraphQL data, to headers or other fields from the request, and much more. [`@shopify/react-html`](https://github.com/Shopify/quilt/tree/master/packages/react-html) provides a set of tools that make it easy to serialize this data on the server, and de-serialize it on the client
* **Basing state or render off globals that differ from the server to the client**. Accessing globals like `window`, `localStorage`, or `MediaQueryList` in a component constructor, state initializer, or render function is always a bug. Instead, grab the necessary values in a `componentDidMount` or `useEffect` function

## Asynchronous component loading

Complex applications generally end up having components that aren’t needed for every render. These can be components that:

* Are only shown for routes in the application that are not currently active.
* Are hidden behind a user action, like modals, or popovers.
* Have large dependencies that would slow down the perceived performance of the app.

The solution for these components is to turn them into "async" components, where the code for the component is only loaded on mount (or later), which frees up the CPU for the rest of the application to render synchronously.

React provides a built-in way of creating async components, [`React.lazy()`](https://reactjs.org/docs/code-splitting.html#reactlazy). This can be a viable approach for simpler cases, but it is missing many features that are usually needed:

* As of this writing, components generated by this function do not work with server side rendering.
* Even if the API itself worked for server rendering, there is no way to determine what application bundles will be needed based on the asynchronous components that were rendered. This is important because failing to include the assets for asynchronously-loaded components will cause the server-rendered markup to be discarded, and will force the download of those assets to happen much later during the initial page load.
* It does not have any built-in mechanism to prefetch any of the assets for the page.

To address these problems, we have developed a few custom packages. [`@shopify/react-async`](https://github.com/Shopify/quilt/tree/master/packages/react-async) provides a function to create asynchronous components based on dynamic import statements:

```tsx
import {createAsyncComponent} from '@shopify/react-async';

const MyComponent = createAsyncComponent({
  load: () => import('./MyComponent'),
});
```

The resulting component has the exact same type signature as the component being asynchronously imported, so the library works great with TypeScript. As documented in [`@shopify/sewing-kit-koa`](https://github.com/Shopify/quilt/tree/master/packages/sewing-kit-koa#usage), sewing kit knows how to attach additional metadata to these components in order to extract the assets they represent for server-rendered applications. Finally, these components have useful static members for prefetching the component’s assets. Strategies for doing so are [documented below](#preloading-strategies).

### Defer strategies

By default, components created by `@shopify/react-async` (and those created by `React.lazy`) start loading the component’s code on mount. This is a great start, but you should be mindful of when you can defer that loading even later. There are two key times that asynchronous components on the page could be loaded:

* **On mount**. This is the default if you render the asynchronous components normally in the parent’s render function.
* **On browser idle**. If a component is unlikely to be used until later in the lifecycle of a component, starting its loading when the browser is idle can be an excellent strategy. Doing so leaves the main thread open for other synchronously-rendered components to perform any `componentDidMount`/ `useEffect` callbacks, without having to contend with th asynchronous component starting its initial load. This strategy can make use of [`window.requestIdleCallback`](https://developer.mozilla.org/en-US/docs/Web/API/Window/requestIdleCallback), which the browser exposes to help developers schedule work when there won’t be resource contention.

`@shopify/react-async` makes it easy to use a specific defer strategy. If you want to use a single strategy for all uses of a component, you can pass it as part of the `createAsyncComponent` call. If it needs to be customized for each "instance", you can pass an `async` prop with this information:

```tsx
import {createAsyncComponent, DeferTiming} from '@shopify/react-async';

const MyAlwaysIdleDeferredComponent = createAsyncComponent({
  load: () => import('./MyComponent'),
  defer: DeferTiming.Idle,
});

const MySometimesIdleDeferredComponent = createAsyncComponent({
  load: () => import('./MyComponent'),
});

<MySometimesIdleDeferredComponent async={{defer: DeferTiming.Idle}} />
```

We recommend deferring async component loading to browser idle in the following cases:

* The component is very infrequently used and will not meaningfully change the layout of the parent component when it loads (this is often the case for content in modals and popovers).
* The component does not have any actual UI and is not needed by other synchronous components. This is often the case for things like tracking.

Additionally, deferring until browser idle is useful when prefetching assets for asynchronous components, which is why the `<Prefetch />` components generated by `@shopify/react-async` does it by default.

### Preloading strategies

One major problem with asynchronous components (as compared to components that are included synchronously in the main bundle of the app) is that the user must wait for these scripts to download and execute before any UI is shown. This cost is always present, but in an all-synchronous world, the cost is paid only once, when the page loads.

To address this problem, developers should attempt to preload assets for components that they are fairly confident will be rendered soon. `@shopify/react-async` provides some useful components to do so, organized around three types of "preloading" that are commonly needed in an application:

* **Prefetching**, where we load code for a page that might be visited soon (but are not certain).
* **Preloading**, where we load code for a page that we are almost certain is going to be visited in the next few seconds.
* **Keeping fresh**, where we refresh asynchronous assets for a component that was recently rendered, and where we are likely to return to (for example, we might want to keep asynchronous-loaded parts of a product list page fresh while we are on the details of a single product).

These types are mirrored in static components returned from `createAsyncComponent`:

```tsx
import {createAsyncComponent} from '@shopify/react-async';

const MyComponent = createAsyncComponent({
  load: () => import('./MyComponent'),
});

<MyComponent.Prefetch />
<MyComponent.Preload />
<MyComponent.KeepFresh />
```

What gets rendered by each of these components can be customized using the `renderPrefetch`, `renderPreload`, and `renderKeepFresh` [options](https://github.com/Shopify/quilt/tree/master/packages/react-async#createasynccomponent). You can use this customization to preload additional asynchronous components that yours depends on.

At a minimum, we recommend rendering the `<Prefetch />` for any asynchronous components that are rendered by a route your component links to. This pattern can be generalized using the [`<PrefetchRoute />` component](https://github.com/Shopify/quilt/tree/master/packages/react-async#prefetchroute-and-prefetcher) in `@shopify/react-async`.
